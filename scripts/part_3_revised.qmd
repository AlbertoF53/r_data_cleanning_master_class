---
title: "Part 3"
author: "Albert Rapp"
date: October 10, 2024
format:
  html:
    code-link: true
    code-fold: true
    code-summary: "Show the code"
    self-contained: true
    embed-resources: true
    toc: true
    theme: Zephyr
    number-sections: false
execute: 
  warning: false
  message: false
  echo: false
editor_options: 
  chunk_output_type: console
---

# Part III

## Lesson 1

This lesson addresses basic string functions, which start with `str_to_`. Those are: `str_to_lower()`, `str_to_upper()`, `str_to_title()`, `str_to_sentence()`.

### Strings for upper or lower capital

```{r loading_libraries}
library(tidyverse)
library(gt)
library(gtExtras)
```

Notice that `str_to_title()` changes the whole string to capital letters. `str_to_title()`capitalizes all the words in the sentence. `str_to_sentence` changes only the first word in the sentence to upper letters. The rest are in lower letters.

```{r basic strings}
#| echo: TRUE

str_to_lower("Berlin")
str_to_lower("This is a sentence")
str_to_upper("This is a sentence")
str_to_title("this is a sentence")
str_to_sentence('Did you know that Berlin is a German city')

# These functions also work with vectors
str_to_lower(c("Berlin", "Madrid", "London", "New York"))
```

#### Practical applications

##### Merging data sets

In this example we are using str_to functions to merge two data sets, whose keys appear either in capital or lower letters.

```{r new_examples_str_to_}
#| echo: true

tib_a <- tibble(
  city = c('Berlin', 'New York', 'Vienna'),
  value = c(452, 242, 2342)
)

tib_b <- tibble(
  city = c('berlin', 'new york', 'vienna'),
  new_value = c(123, 2341,25234)
)

#*  Trying to join them would fail to bring the values of the
#*  new_value variable in tib_b because of the keys

tib_a |> 
  left_join(tib_b)


```

Using `str_to_` to make compatible the two data sets. Notice the use of `mutate`.

```{r joining_after_str_to}
#|echo: true

tib_a |> 
  left_join(
    tib_b |> 
      mutate(city = str_to_title(city)),
    by = join_by(city == city))

# Another option is to change tib_b before doing the merger

# tib_b <- tib_b |> 
#   mutate(city = str_to_title(city))
# 
# tib_a |> 
#   left_join(
#     tib_b, by = join_by(city == city)
#   )

```

##### Tables

Another useful application is when creating tables. Say you want to capitalize the names of the variable, in this case city. Instead of manually change the titles in the gt() table you can include str_to_title() within gt()

```{r creating_tables_str_to}
#|echo: TRUE

library(gt)

tib_a |> 
  gt() |> 
  cols_label_with(fn = str_to_title)

```

## Lesson 2

### `str_detect()`

Finding things related to specific texts.

```{r finding_characters}
#|echo: TRUE

cities <-  c('Berlin', 'New York', 'Vienna')

#Identifying cities with the letter B

str_detect(cities, 'B')

#Identifying cities with the letter e

str_detect(cities, 'e')



```

#### Using str_detect() along with filter() function

Watch up that `str_detect()` is case sensitive.

```{r str_detect_filter}
#| echo: true

#Filtering cities with the letters "Ber"

tib_a |> 
  filter(str_detect(city, 'Ber'))

tib_a |> 
  filter(str_detect(city, 'nn'))


```

Using `str_subset()` instead of `str_detect()` if interested in pulling the set of values

```{r str_subset}
#| echo: true

str_subset(cities, 'Ber')

```

Using the `str_which()` function, which provides an index of the elements that match the string.

```{r str_which}
#| echo: true

str_which(cities, 'Yo')

```

## Lesson 3

Functions that look at the start or end of a string: `str_starts() str_ends()`.

```{r openning_ending_stings}
#| echo: true

cities <-  c('Berlin', 'New York', 'Vienna')

str_starts(cities,'Ber')

str_ends(cities, 'rk')

```

Function that detects characters `str_detect()`

```{r detective_function}
#| echo: true

cities <-  c('Berlin', 'New York', 'Vienna')

str_detect(cities, 'n')

```

Using a similar approach to subsets via \[\] brackets. It lists the name of the value meeting the condition.

```{r detect_subset}
#| echo: true

cities <-  c('Berlin', 'New York', 'Vienna')

cities[str_starts(cities,'n')]

cities[str_ends(cities,'n')]

which(str_ends(cities,'n'))

```

## Lesson 4

Using the negative argument.

-   The negate argument nullifies what is indicated in the `str_starts()` function. The full function is str_starts(string, pattern, negate = FALSE).

```{r negating_arg}
#| echo: true
#| message: false

library(tidyverse)

cities <-  c('Berlin', 'New York', 'Vienna')

#Here we see all three arguments are false

str_starts(cities, 'ber')

#Watch what happens when we add the negate argument within the str_

str_starts(cities, 'ber', negate = TRUE)


```

Another example of the use of negate.

Using the first option `str_detect()`reports that New York does not meet the condition of having an n.

-   Watch what happens, when we add the negate argument. In this case New York meets the condition of having an `n`.

-   Another option is to use the negate expression `!`at the beginning of the string. This option means: "Find all those cities that do not have a capital N." In this case, New York does not have a capital 'N' letter, but a lower capital "n" instead, making the logical condition`TRUE`.

```{r negate_v2}
#| echo: true
#| message: true

cities <-  c('Berlin', 'New York', 'Vienna')

str_detect(cities, 'n')

#Adding negate

str_detect(cities, 'n', negate = TRUE)

#Adding negate expression at the beginning

!str_detect(cities, 'n')


```

A situation where the `negate = TRUE` is useful is in those condition where one does not want to return TRUE or FALSE .

-   The first str_subset identifies Berlin and Vienna has having lower capital "n"s.

-   In the second case, we can use to identify the names of cities not containing lower case 'n's.

```{r negate_v3}
#| echo: true
#| warning: true

#First option
str_subset(cities, 'n')

#Second option
str_subset(cities, 'n', negate = TRUE)

```

## Lesson 5

Removing unwanted text, or changing the text. The main focus is the `str_remove( )`. This function works by removing a string and replacing it by another.

There are two options: `str_remove( )` and `str_remove_all( )`.

In this example we focus on the string 'Alabama', where we want to remove the letter `a`.

-   str_remove('Alabama', "a") only removes the first "a"

-   str_remove_all('Alabama','a') removes all as

```{r rem_unwanted}
#| echo: true

str_remove('Alabama', 'a')

#Removing all "a"s

str_remove_all('Alabama', 'a')

#Removing lower & capital a's

str_remove_all('Alabama', 'a|A')


```

A nice application showing case the power of str_remove() function

-   In this case we want to remove unnecessary labels associated with the name of companies

```{r rem_unwanted_v2}
#| echo: true

# library(readr)
# big_tech_companies <- read_csv("data/Part_2/big_tech_companies.csv")
# 
# saveRDS(big_tech_companies, 
#         file = 'data/Part_2/new_big_tech.rds')
#   
big_tech_companies <- readRDS("~/Documents/GitHub/r_data_cleanning_master_class/data/Part_2/new_big_tech.rds")


```

Cleaning the data using mutate function along with `str_remove()` function

-   Removing Inc. by a space

-   Removing commas followed by a white space

-   Removing ".com"

-   Removing "Corporation"

-   Removing "Systems"

-   Removing Platforms

```{r removing_labels}
#| echo: true

big_tech_companies |> 
  mutate(
    company = company |> 
      str_remove("Inc.") |> 
      str_remove(", ") |> 
      str_remove(".com") |> 
      str_remove(' Corporation')
  )

```

Important note. In regular expression language some symbols have special meaning. For example, in the string `Inc.` the period means "any character".

## Lesson 6

Trim and pad your strings.

As you noticed, there are some unwanted spaces at the end of the names of the companies. We can eliminate those unwanted spaces using the `str_trim()` function, which removes whitespaces.

On the other hand, `str_squish()` removes whitespace at the start and end, and replaces all internal whitespace with a single space. Notice that the " " disappears once you trim the string.

```{r trim_pad}
#| echo: true

big_tech_companies |> 
  mutate(
    company = company |> 
      str_remove("Inc.") |> 
      str_remove(", ") |> 
      str_remove(".com") |> 
      str_remove(" Corporation") |> 
      str_trim(side = c('both'))
  )

```

The str_padd() does opposite of str_trim(). It adds spaces.

Consider the example of making certain that a string of numbers have the same length. And we want to add a `0` to the left of the character instead of whitespace. In this example, we are adding to zeros to the left of the digit.

```{r str_pad}
#|echo: TRUE

1:15

str_pad(
  1:15,
  width = 4,
  side = c('left'),
  pad = '0'
)

```

## Lesson 7

### Concatenate strings

#### paste0( ) function

Using the padded numbers to create file names. We can create a new file labelled `file_names`. And then use the `paste0` function and then add the string `_file.txt`. paste() function is similar to paste0 except it leaves a space between the two string being attached.

```{r concatenate_string}
#| echo: true
#| message: false

padded_mmbrs <-  str_pad(
   1:15,
  width = 4,
  side = c('left'),
  pad = '0'
)

#Pasting the extention _file.txt with space using paste()
file_names <- paste(
  padded_mmbrs,
  "_file.txt"
)

#Pasting the extention _file.txt without space using paste0()
file_names <- paste0(
  padded_mmbrs,
  "_file.txt"
)

```

#### `str_c` concatenate function

Similar to paste0(), but `str_c` has a couple of safety features that makes it nicer to work with.

```{r str_concatenate}
#| echo: true

str_c(
  padded_mmbrs,
  '_file.txt'
)


```

#### Collapsing vectors of text

For example using the file_names vector via paste0(file_names) nothing happens

```{r collapsing_vectors_txt}
#| echo: true

paste0(file_names)


```

An alternative using paste0() to collapse all the strings within into a single string, here using collapse to add a comma and a white space `paste0(file_names, collapse = ', ').`

```{r collapsing_vectors_txt_v2}
#|echo: TRUE

#Adding a comma and space when collapsing string
paste0(file_names, collapse = ', ')

#Same thing happens using str_c()

str_c(file_names, collapse = ', ' )

```

The str_c function is a preferred option to paste0() in several cases. One of them when combining strings with missing values.

```{r collapse_missing}
#|echo: TRUE

#Using paste0() to collapse NA
paste0(c(file_names,NA), collapse = ', ')

#Using str_c() to collapse NAs is preferred
str_c(c(file_names, NA), collapse = ', ')


```

##### str_flatten

`str_flatten( )` reduces a character vector into a single string. It is a summary function in that regardless of the length of the input x, it returns a single string.

-   str_flatten(string, collapse = , )

The str_flatten function has another advantage next to paste0() and str_c(). It allows you to modify the last entry in the string to include a symbol marking using the argument last = " and ". Because this option is so common, there is even an Oxford version of the str_flatten function: str_flatten_comma().

```         
str_flatten_comma(string, last = NULL, na.rm = FALSE)
```

```{r str_flatten}
#| echo: true

#This option produces same results as paste0() and str_c()
str_flatten(file_names, collapse = ', ')

#However str_flatten() has another option allowing to add a string
str_flatten(file_names, collapse = ', ', last = ' and ')

#Demonstrating the same using the first 3 names
str_flatten(file_names[1:3], collapse = ', ', last = ', and ')

#Oxford version
str_flatten_comma(file_names[1:3],last = ', and ')

```

## Lesson 8

### glue & epoxy

#### glue package

In the real world you want to preface a collapse vector with a short explanation of what it stands for. glue() and epoxy() functions add explanations to collapsed strings. To add variables within the glue function use `{ }`. **Be careful** about using [single quotation]{.underline} mark when inserting the column or variable. *Use double quotation mark " "instead*.

```{r glue_epoxy}
#| echo: true

library(glue)
library(epoxy)

glue::glue(
  "The relevant files are: 
  {str_flatten_comma(file_names[1:3],last = ', and ') }"
  )

# Adding more text at the end of glue

file_location <- 'somewhere'


glue::glue(
  "The relevant files are: 
  {str_flatten_comma(file_names[1:3],last = ', and ') } and they are located {file_location}." 
  )

```

#### epoxy package

epoxy is like glue package but with steroids.

It works like glue(). It produces the same output

```{r epoxy_pck}
#| echo: true

library(epoxy)

file_location <- 'somewhere'


epoxy::epoxy(
  "The relevant files are: 
  {str_flatten_comma(file_names[1:3],last = ', and ') } and they are located {file_location}." 
  )

```

Additional epoxy features. Notice we don't need to flatten the string as we did with glue()

```{r addition_epoxy_feat}
#| echo: true

file_location <- 'somewhere'

#Notice this option lists each file 
epoxy::epoxy(
  "The relevant files are: {file_names[1:3]} and they are located {file_location}." 
  )

#To produce a single string, whereby the comma is specified in advance.
epoxy::epoxy(
  "The relevant files are: {.comma file_names[1:3]} and they are located {file_location}." 
  )

#* The same works with other special arguments like adding 'and'
epoxy::epoxy(
  "The relevant files are: {.and file_names[1:3]} and they are located {file_location}." 
  )

#* Using or instead of and
epoxy::epoxy(
  "The relevant files are: {.or file_names[1:3]} and they are located {file_location}." 
  )

```

## Lesson 9

### Replace texts with str_replace( )

In the example, the goal is to modify the original sentence using the `str_replace( )`function. There are several options of str_replace:

-   str_replace( )

-   str_replace_all( )

-   str_replace_na( )

```{r replace_txt}
#| echo: true


sentence <-  'Peter is a nice guy and Tom is a mean guy while Maria is NA'

#Replacing nice by another word, or empty space
str_replace(sentence,'nice','')

str_replace(sentence,'guy','dude')

#Using the str_replace_all function

str_replace_all(sentence,'guy','dude')

# Replacing a string with an NA

str_replace_na(sentence, replacement = "NA")


```

This function can be a life savvier when joining data sets. Notice that in the second dataset Washington DC is not spelled the same way as in the first dataset, producing an NA when merging the data

```{r replace_join_role}
#| echo: true

population <- tibble(
  city = c("New York", "Washington D.C."),
  inhabitants = runif(2, max = 10^7) |> 
    round()
)

area <-  tibble(
  city = c("New York", "Washington DC."),
  area_m2 = runif(2, max = 10^7) |> 
    round()
)

#* One approach is to replace "Washington DC." by "Washington D.C." in
#* the are df before merging the two datasets

area |> 
  mutate(
    city = city |> 
      str_replace("Washington DC.", "Washington D.C."))

#Or

area <- area |> 
  mutate(
    city = str_replace(city, "Washington DC.", "Washington D.C." ) )


population |>
  left_join(area, 
            by = 'city')


```

Second approach to replace the incorrect spelling of DC. Notice that `str_replacement_all( )` has a hidden feature. It can be used to perform multiple replacements using regexp.

```{r 2nd_approach_join}
#| echo: true

population <- tibble(
  city = c("New York", "Washington D.C."),
  inhabitants = runif(2, max = 10^7) |> 
    round()
)

area <-  tibble(
  city = c("New York", "Washington DC."),
  area_m2 = runif(2, max = 10^7) |> 
    round()
)

population |>
  mutate(
    city = str_replace_all(city,"D.C.", "DC." )
  ) |> 
  left_join(area, 
            by = 'city')


```

### Replacement dictionary

In this example we have two cities that need replacing 'D.C.' by 'DC.' and New York by New York City. We can do so by creating a dictionary of the replacements to be made before joining the two databases.

Notice that the area is being modified by a mutate command within the left_join function prior to using the key merging variable; in this case, city.

```{r hidden_feature}
#| echo: true

population <- tibble(
  city = c("New York", "Washington D.C."),
  inhabitants = runif(2, max = 10^7) |> 
    round()
)

area <-  tibble(
  city = c("New York City", "Washington DC."),
  area_m2 = runif(2, max = 10^7) |> 
    round()
)

#* Creating a replacement dictionary
#* 

replace_dict <- c("New York City" = "New York",
                  "Washington DC." = "Washington D.C.")

#* Notice that the area df is being modified by the mutate function before
#* matching with whe key, city. 

population |> 
  left_join(area |> 
            mutate(
              city = str_replace_all(city, replace_dict )
            ),
            by = 'city')


```

## Lesson 10

This lesson examines how to split strings.

### Splitting sentence with spaces

```{r splitting_strings}
#| echo: true
#| warning: false

sentences <- c(
  "Petter is a nice guy and Tommy is a mean guy",
  "Lisa is a nice lady and Jenny is a mean lady"
)

str_split(sentences, " " )

#This function can also be used to split a word

str_split('Flapjack', '' )


```

### str_split_1() function

It can be used to get the results as a vector. `str_split_1()` takes a single string and splits it into pieces. It returns a character

```{r str_split_1()}
#| echo: true
#| message: false

str_split_1('Flapjack', '')


```

### str_split_i() function

Splits each string into a character vector into pieces and extracts the ith value, returning a vector. This function is ideal if we want to single out an attribute or string located in a particular position in the vector

Suppose we want to single out the 5th word or letter in a string. In this case, 'guy', and "lady".

```{r str_split_i() }
#| echo: true
#| message: false

str_split_i(sentences, ' ', i = 5)

```

#### Applications

This function could help to identify important elements in a vector. For example ingredients in a recipe. In this case single out the second element.

```{r str_split_ingredients}
#| echo: true
#| message: false

recipe <- c("5 beer",
  "6 onions",
  "7 cucumbers")

 
str_split_i(recipe,' ', i = 2)



```

#### Creating data sets

This could be useful in a tibble data set, which identifies the ingredients as a second column. If we want to have a column with the quantity using the parse_number() from the `readr`package

```{r tibble_str_split}
#| echo: true
#| message: false

tibble(
  input = c("5 beer",
  "6 onions",
  "7 cucumbers")) |> 
  mutate(
    quantity = parse_number(input),
    unit =   str_split_i(input,' ', i = 2)
  )

```

### str_split_fixed

`str_split_fixed()` can be used to break down a string into 3 splits.

```{r str_split_}
#| echo: true
#| message: false

str_split_fixed(sentences,' ', n = 3)


```

## Lesson 11

### separate_wider\_ function

Split columns with `separate_wider_delim()`. It is part of the tidyr package. It allows us to separate string by a delimiter. We need to indicate the column to be split, in this case; content. Basically, it breaks a long string into columns. It has many options.

```{r spliting_columns}
#| echo: true
#| message: false

mixed_col <- tibble(
  content = c("5 beer",
  "6 onions",
  "7 cucumbers"))

#Two options

separate_wider_delim(
  data = mixed_col,
  cols = 'content',
  delim = ' ',
  names = c('quantity','unit')
)


#Pipe option |>

mixed_col |> 
  separate_wider_delim(
  cols = 'content',
  delim = ' ',
  names = c('quantity','unit')
)


```

#### debug option

A more complicated example. Notice the last entry has more than two pieces of data, which prompts an error. We need to use he option `too-many` argument. If unsure what to do, you could use the 'debug' option. This option shows what is wrong.

```{r split_col_comp }
#| echo: true
#| message: false

mixed_col <- tibble(
  content = c("5 beer",
  "6 onions",
  "7 cucumbers",
  "8 pieces of bread"))

#too_many = debug


mixed_col |> 
  separate_wider_delim(
  cols = 'content',
  delim = ' ',
  names = c('quantity','unit'),
  too_many = "debug"
)


```

#### merge

One way to correct the problem is to merge "pieces of bread".

```{r split_col_comp_merge }
#| echo: true
#| message: false

mixed_col |> 
  separate_wider_delim(
  cols = 'content',
  delim = ' ',
  names = c('quantity','unit'),
  too_many = "merge"
)

```

#### drop

```{r split_col_comp_drop }
#| echo: true
#| message: false

mixed_col |> 
  separate_wider_delim(
  cols = 'content',
  delim = ' ',
  names = c('quantity','unit'),
  too_many = "drop"
)

```

#### An example of too few

The last row, Houston, does not indicate the state of the city. The debug option reveals that the last row, Houston, is FALSE in that it is too short. It lacks the state.

```{r split_col_comp_too_few}
#| echo: true
#| message: false

# tibble(
#   city = c(
#     "New York, NY",
#     "San Diego, CA",
#     "Houston"
#   )
# ) |> 
#   separate_wider_delim(
#   cols = 'city',
#   delim = ',  ',
#   names = c('city','state')
# )

#Using the `too_few` argument with the debug optin

# tibble(
#   city = c(
#     "New York, NY",
#     "San Diego, CA",
#     "Houston"
#   )
# ) |> 
#   separate_wider_delim(
#   cols = 'city',
#   delim = ', ',
#   names = c('city', 'state'),
#   too_few = 'debug'
# )



```

#### too_few = 'align_start'

We have two option to correct the problem: align_start or align_end. Opting for \`too_few = align_start'. The align_start option creates two columns. In the case of Houston, it reports the state as NA.

```{r split_col_comp_aling_start}
#| echo: true
#| message: false

tibble(
  city = c(
    "New York, NY",
    "San Diego, CA",
    "Houston"
  )
) |> 
  separate_wider_delim(
  cols = 'city',
  delim = ', ',
  names = c('city', 'state'),
  too_few = 'align_start'
)



```

#### too_few = 'align_end'

Using the align_end to correct the problem is missing state for Houston. In this case, the last entry reports city as NA and state = Houston.

```{r split_col_comp_aling_end}
#| echo: true
#| message: false

tibble(
  city = c(
    "New York, NY",
    "San Diego, CA",
    "Houston"
  )
) |> 
  separate_wider_delim(
  cols = 'city',
  delim = ', ',
  names = c('city', 'state'),
  too_few = 'align_end'
)


```

### separate_longer

It operates as `separate_wider` but in the opposite direction. It does not give you many columns but instead rows.

## Lesson 12

Regular expressions.

```{r reg_exp_intro}
#| echo: true
#| message: false

#Removing lower as

str_remove_all('Alabama', 'a')

#Removing captial As

str_remove_all('Alabama', 'A')


```

### str_remove() and regex

Removing both capital and lower a's using regular expressions. We can remove capital or lower a's using or `|` operator. Recall that the second argument in the `str_remove()` deals with the `pattern` we are looking for.

```{r str_remove_regex}
#| echo: true
#| warning: false

str_remove_all('Alabama', 'a|A')


```

### str_subset() and regex

In this example, we want to subset the string by singling out cities with either capital B or lower cap b. Another example

```{r str_subset_regex}
#| echo: true
#| warning: false

str_subset(
  c('Berlin', 'New York', 'Vienna'),
  'B|b'
  
)

```

### str_detect and regex

This function returns TRUE or FALSE for those cities meeting the regex condition or pattern.

```{r str_detect_regex}
#| echo: true
#| warning: false

str_detect(
  c('Berlin', 'New York', 'Vienna'),
  'B|b'
)


```

### Expanding on `or` `|` operator

In this example we want to subset Berlin, but without caring if it spelled with a capital or lower B.

Notice we also pulled out Brussels although it was not our intention. Using `string_view` reveals the reason Brussels was included. view is used to print the underlying representation of a string and to see how a `pattern` matches.

In this case the `|` operator searches that patterns that match to the right or left of it.

```{r expanding_|_or}
#| echo: true
#| warning: false

str_subset(
  c('Berlin', 'Brussels', 'New York', 'Vienna'),
  'B|berlin'
)

#*To figure it out using str_view, which prints the underlying
#*represention of a string and how a pattern matches

str_view(
  c('Berlin', 'Brussels', 'New York', 'Vienna'),
  'B|berlin'
)

```

Instead of using `|`, `or`, we want to instruct the string_subset to select cities that start with capital B or lower b and are followed by the string `erlin`. In this case only one entry satisfies this condition: `<Berlin>`.

In regex, parenthesis `( )` are regular expressions to group things together.

```{r restricting_or_via_parenthesis}
#| echo: true
#| warning: false

str_view(
  c('Berlin', 'Brussels', 'New York', 'Vienna'),
  '(B|b)erlin'
)

str_subset(
  c('Berlin', 'Brussels', 'New York', 'Vienna'),
  '(B|b)erlin'
)

str_detect(
  c('Berlin', 'Brussels', 'New York', 'Vienna'),
  '(B|b)erlin'
)


```

## Lesson 13

RegEx. The `.` operator and how to escape it.

In this new data set there are four rows. Each with a name and her corresponding email.

```{r escaping_period_operator}
#| echo: true
#| warning: false

contact_info <- tibble(
  name = c(
    "Otto Bauer", "Lisa Hundsgemein",
    "Leah LastName", 'Nora Whats-Her-Name'),
  mail = str_to_lower(name) |> 
    str_replace_all(' ', '.') |> 
    paste0(
      c("@communicators.de",
        "@communicators.de",
        "@microsoft.com",
        "@apple.com")
    ) )

contact_info

```

The exercise is to filter out the emails that end with `.com` .

The first option is to use `str_detect` with searching for `.com`. However, this option does not single out the cases with .com . To see what is going on, we can ask for the `str_view()`

The string view reveals the error.: Caused by error: ! `..1` must be a logical vector, not a <stringr_view> object.

```{r filtering_emails_str_detect}
#| echo: true
#| warning: false

library(tidyverse)

contact_info |> 
  filter(str_detect(mail,".com"))

str_view(contact_info$mail, '.com')


```

The `str_view` reveals that dot and dot.com `.` and `.com` matches two separate things. In one cases it matches to the `@` and in and in another case it matches to `.com`. This is why you get all rows returned.

There are two ways to fix this problem, One is using the fixed option in str_view(), and the second option is escaping the special characters.

#### Using the fixed option

In this case, we indicate the pattern we are searching for after fixed.

```{r fixed_solution}
#| echo: true
#| warning: false

str_view(contact_info$mail, fixed('.com'))


```

#### Escaping especial characters

We modify the special characters so that the regular expression. R automatically regards perido `.` as a control character. We need to teach R to understand not using the `.` as a special character but as a point. We do so using double backslash `\\`. If you use a single backslash you will get the following error:

"Error: '.' is an unrecognized escape in character string (<input>:1:31)"

The reason being R also has especial characters. For example `\n` is recognized by R as to signify a break line. For example `cat(A\nB)` means to separate A and B in different lines.

```{r special_characters_r}
#| echo: true
#| warning: false

cat('A\nB')

#Scapping the meaning of breaking a line

cat('\\.com')

```

Because of the this reasons we need to use double backslash. In other words, you need to tell R not to use `\` as a special indicator for breaking a line. In other to do so, we need a double `\\`.

`cat('\\.com')`

R interprets the first `\` as meaning a literal backslash while the second backslash signifies treating the dot `.` as a regular thing and not an special operator.

```{r escaping_regex_double}
#| echo: true
#| warning: false

#Using `\` to escape the special function associated with dot.

str_view(contact_info$mail, '\\.com')


```

## Lesson 14

Using the last data set. In this exercise we want to extract data from the mail column. For instance, we may want to extract characters before the `@` symbol and string after the `@` symbol. For instance, we may want to extract people who use the apple email domain.

Using `str_match()` to extract strings from a vector.

Notice the dot operator `.` can be used to identify strings. To identify more symbols before or after the dot operator, we can use the `+` operator.

```{r str_match_dot}
#| echo: true
#| warning: false

library(tidyverse)

contact_info <- tibble(
  name = c(
    "Otto Bauer", "Lisa Hundsgemein",
    "Leah LastName", 'Nora Whats-Her-Name'),
  mail = str_to_lower(name) |> 
    str_replace_all(' ', '.') |> 
    paste0(
      c("@communicators.de",
        "@communicators.de",
        "@microsoft.com",
        "@apple.com")
    ) )

#Finding things that match the @ symbol

str_match(contact_info$mail, '@')

#Using the dot operator in front and back

str_match(contact_info$mail, '.@.')

#If we want all the characters after the @ symbol

str_match(contact_info$mail, '.@.+')

#Examples of intermediate steps using `+` and `.`

str_match(contact_info$mail, '.@.')

str_match(contact_info$mail, '@.+')

str_match(contact_info$mail, '.@.+')

str_match(contact_info$mail, '.+@.+')



```

### Searching for specific groups

str_match can be used to look for specific groups. The key for making groups is to use the special characters `( )` for grouping things together in front and back. This expression breaks the sentences into three groups.

```{r str_match_groups}
#| echo: true
#| warning: false

str_match(contact_info$mail, '(.+)@(.+)')


```

If we want to extract the first and last name. Notice that a dot separates the first name from the last name.

The str_match below produces 3 groups, but not the output we wanted. Our grouping uses the wrong dot `.`.

```{r extract_last_first_name_first}
#| echo: true
#| warning: false

str_match(contact_info$mail, ('(.+)\\.(.+)'))

```

We can instruct our regular expression to stop at the add sign `@`. This regular expression produces three columns. The first one we don't want. The last two contain the first and last name we want to keep.

```{r extract_names_only}
#| echo: true
#| warning: false

str_match(contact_info$mail, ('(.+)\\.(.+)@'))

```

Finally, once cool thing we could do is to take this part and remove everything at the first column. We can do so using brackets `[, -1 ]` indicating we want to keep all rows while removing the first column. Recall, this bracket was produced by *str_match(contact_info\$mail, ('(.+)\\.(.+)\@'))* indicating the column with the unwanted string.

```{r extract_names_remove_everthing}
#| echo: true
#| warning: false

str_match(contact_info$mail, ('(.+)\\.(.+)@'))[, -1] |> 
  as_tibble()

```

However, we get a warning message:

Warning message: The `x` argument of `as_tibble.matrix()` must have unique column names if `.name_repair` is omitted as of tibble 2.0.0. Using compatibility `.name_repair`.

Thus we can add a `name_repair` which contains a function that throws the first and last name.

```{r extract_nmes_name_repair}
#| echo: true
#| warning: false

str_match(contact_info$mail, ('(.+)\\.(.+)@'))[, -1] |> 
  as_tibble(.name_repair = function(x) c('first', 'last') )


```

## Lesson 15

### Creating columns using mutate() and string_match

This option produces the same results as str_match, but while creating columns. We need to include a mutate, while using the same match function as before.

```{r separate_wider}
#| echo: true
#| warning: false

contact_info <- tibble(
  name = c(
    "Otto Bauer", "Lisa Hundsgemein",
    "Leah LastName", 'Nora Whats-Her-Name'),
  mail = str_to_lower(name) |> 
    str_replace_all(' ', '.') |> 
    paste0(
      c("@communicators.de",
        "@communicators.de",
        "@microsoft.com",
        "@apple.com")
    ) )

contact_info |> 
  mutate(
    matches = str_match(mail,'(.+)\\.(.+)@'),
    first = matches[,2],
    last = matches[,3]
  ) |> 
  select(c('first', 'last'))


```

### Split text column with separate_wider_regex()

This option has a better workflow next to str_match. In contrast to str_match, instead of using the group pattern as is, you have to specify a vector that splits the pattern. Everything that is named inside the vector would become a column.

Notice that we not longer need the grouping `()`, since the grouping already takes place when specifying the patterns.

```{r separate_wider_regex_option_v1}
#| echo: true
#| warning: false

contact_info |> 
  separate_wider_regex(
    cols = mail,
    patterns = c(
      first_name = '.+',
      '\\.',
      last_name = '.+',
      '@'
    )
  )

```

However, this would prompt an error message

**Error in `separate_wider_regex()`: ! Expected each value of `mail` to match the pattern, the whole pattern, and nothing but the pattern.**

In order to correct the problem, we need to instruct R that after the add symbol `@` one or more characters can be encountered. This means adding the following regex `@.+`

```{r separate_wider_regex_option_v2}
#| echo: true
#| warning: false

contact_info |> 
  separate_wider_regex(
    cols = mail,
    patterns = c(
      first_name = '.+',
      '\\.',
      last_name = '.+',
      '@.+'
    )
  )

```

## Lesson 16

### Create a collection of patterns to look for

This lesson deals with another operator: `str_remove_all()`

The data set adds additional numbers to some names. Those names need to be cleaned by removing the numbers in the name column (e.g., Otto Bauder 21). As a pattern, we need to specify numbers. In regexp you can use brackets to wrap the things we want `[ ]` to collect. In this case numbers. So we could use `[0-9]`.

```{r patterns_collection}
#| echo: true
#| warning: false

contact_info2 <- tibble(
  name = c(
    "Otto Bauer", "Otto Bauder 2",
    "Otto Bauder 21", "Lisa Hundsgemein",
    "Leah LastName", 'Nora Whats-Her-Name'),
  mail = str_to_lower(name) |> 
    str_replace_all(' ', '.') |> 
    paste0(
      c("@communicators.de",
        "@communicators.de",
        "@microsoft.com",
        "@apple.com")
    ) )

#Passing dataset to mutate & specifying numbers to remove

# First option removes just one number 1
contact_info2 |> 
  mutate(
    name = str_remove_all(
      name,'[1]' )
  )

# Second option removes just 1 and 2
contact_info2 |> 
  mutate(
    name = str_remove_all(
      name,'[12]' )
  )

#Third option creates a group of potential numbers to remove
contact_info2 |> 
  mutate(
    name = str_remove_all(
      name,'[0-9]' )
  )

#In order to remove the spaces leftout, we could use str_trim

contact_info2 |> 
  mutate(
    name = str_remove_all(
      name,'[0-9]' ),
    name = str_trim(name))



```

#### Eliminating white space by using regular expressions

-   One option is to add a space in front of the number collection `[0-9]`. But this option did not eliminate all of the numbers. R in this case targets the first number only.

-   What we need to specify is to eliminate one space followed by one or more numbers. We can do so by adding the plus `+` operator. As seen, the plus operator also works on collections. In the regexp `[0-9]+` the `+` operator refers to the thing in front of it. Technically the one thing in front of plus operator is the bracket \[0-9\]. R reads then `[0-9]+` as the whole collection in front of the plus operator.

```{r regexp_elim_spaces}
#| echo: true
#| warning: false

#One option is to include the white space in front of the collection
contact_info2 |> 
  mutate(name = str_remove_all(name,' [0-9]' ) )

#Second option is to include the + operator
contact_info2 |> 
  mutate(name = str_remove_all(name,'[0-9]+' ) )


```

## Lesson 17

### Looking for optional texts and non-grouping parentheses

Let's split emails as we did before using str_match( mail, '(.+)\\\\.(.+)\@'). However,this option produces a rather messy output. In two cases, it did not split into first and last name.

We would also learn about a special operator for optional things `?:`.

```{r look_op_texts}
#| echo: true
#| warning: false

contact_info2 <- tibble(
  name = c(
    "Otto Bauer", "Otto Bauder 2",
    "Otto Bauder 21", "Lisa Hundsgemein",
    "Leah LastName", 'Nora Whats-Her-Name'),
  mail = str_to_lower(name) |> 
    str_replace_all(' ', '.') |> 
    paste0(
      c("@communicators.de",
        "@communicators.de",
        "@microsoft.com",
        "@apple.com")
    ) )

str_match(contact_info2$mail, '(.+)\\.(.+)@')

```

We want a regexp expression that catches a collection of letters too.

One option is illustrated below, which does not produced the desired outcome. The thing is we are looking for something followed by a dot `.` followed by a group of characters followed by an `@` . However, group of characters are not followed immediately by `@` . For instance in `otto.bauder.21@` what follows after the second group of characters are numbers.

```{r catching_coll_letters}
#| echo: true
#| warning: false

str_match(contact_info2$mail, '(.+)\\.([a-z]+)@')

```

Since we have grouped together the characters, we no longer need the add sign `@`. However, the result is not satisfactory.

The problem is that the first regular expression group `(.+) catches too many things. Deleting the`2`@` sign.

```{r catching_coll_letters_v2}
#| echo: true
#| warning: false

str_match(contact_info2$mail, '(.+)\\.([a-z]+)')


```

One solution is to alter the first section of the regular expression to catch group of letters preceding the period.

We successfully split the mail into three columns. The last two columns have what we want. However, the name of Nora is now incomplete. Nora's complete name is whats-her-name.

The reason is that Nora's name contains the character `-` embedded within the letters.

```{r catching_coll_letters_v3}
#| echo: true
#| warning: false

str_match(contact_info2$mail, '([a-z]+)\\.([a-z]+)')

```

Adding the second group the character `-` as part of the second group of letters; namely `[a-z-]`

```{r catching_coll_letters_v4}
#| echo: true
#| warning: false

str_match(contact_info2$mail, '([a-z]+)\\.([a-z-]+)')

```

### Looking for optional things

#### adding subgroups

What if for some reason we also want to catch the numbers included in some of the emails as part of the name? In this case, notice that the inclusion of numbers is optional in some cases. For this situation `?` the question mark operator allows for flexibility. The question mark stands for `optional`.

Modifying the regular expression to read as follows: match the first group of letters before the period `([a-z]+)`. Next, capture the group of letters including the `-` sign, or a group of numbers `([a-z-]+)`. Then, skip another period and catch a group of numbers `([0-9]+)`.

However, this option would produce missing data except for the two cases that have numbers in their emails

```{r catching_numbers_as_well}
#| echo: true
#| warning: false

#This option won't produce the intended outcome

str_match(contact_info2$mail, '([a-z]+)\\.([a-z-]+)\\.([0-9]+)')


```

#### adding optional ?

Adding the optional symbol `?` alerts R to distinguish those cases where numbers are embedded within the email address (e.g., otto.bauder.21\@microsoft). We also clarify the the second dot in the email preceding the number is optional. So we need to declare it as a group as follows: `(\\.[0-9]+)?`, which will capture `.21` in otto.bauder's email portion.

```{r catching_numbers_as_well_optional}
#| echo: true
#| warning: false

#Adding the optional presence of numbers in the email address
str_match(contact_info2$mail, '([a-z]+)\\.([a-z-]+)(\\.[0-9]+)?')

```

Notice this str_match produced 4 columns. Column \[,4\] captures the two email cases with numbers in them.

#### Looking for just the numbers in the email

What is we just want the numbers without the dot.

##### The first option is to include the third group reporting that the numbers in the name are optional

```{r last_numbers_optional}
#| echo: true
#| warning: false

str_match(contact_info2$mail, '([a-z]+)\\.([a-z-]+)\\.([0-9]+)?')


```

The problem is traced to the fact the regular expression treats the period `.` as if it were present for all the names. However, this condition is present in only two names `otto.bauder2` and `otto.bauder.21`. But for the reminder 4 names there is no point preceding the `@` sign. This is why, we need to include the `.` as a part of the optional group. So we are making the dot `.` along with the numbers optional with `?`.

```{r group_optional_2}
#| echo: true
#| warning: false

str_match(contact_info2$mail, '([a-z]+)\\.([a-z-]+)(\\.([0-9]+))?')
```

The end result is 5 columns. Column \[,5\] we don't need because it repeats column \[,4\].

#### Just keeping the numbers column.

One way is to manipulate the parenthesis to group things together without including other characters. "Tell the parenthesis it should group things together, but should not count it as a group parenthesis". We can do so by including the question mark at the beginning of the group, followed by the column operator. `?:`

```{r just_numbers_column_no_dot}
#| echo: true
#| warning: false

str_match(contact_info2$mail, '([a-z]+)\\.([a-z-]+)(?:\\.([0-9]+))?')

#Another option yielding the same result

str_match(contact_info2$mail, '([a-z]+)\\.([a-z-]+)(\\.[0-9]+)?')

```

## Lesson 18

### Extracting first and last name

#### Using `str_match()`

Working with the name column. Extracting the first and last name.

Basically we have two groups of string separated by a white space. Or `([a-z]+  ([a-z]+ )`. This option won't work since regexp is case sensitive. Moreover, Nora's last name is separated by `-` that need to be included in the regexp.

This regular expression tells str_match to use column name as the target. Next use two groups of strings. The first string group consists of several letters `([a-z]+)`. Then a space separates the second group of strings. The second group of string also includes several letters and include `-` `([a-z-]+)`.

Problem is that letters include both lower and capital letters the regexp needs to include.

```{r match_groups_case_sensite}
#| echo: true
#| warning: false

contact_info2 <- tibble(
  name = c(
    "Otto Bauer", "Otto Bauder 2",
    "Otto Bauder 21", "Lisa Hundsgemein",
    "Leah LastName", 'Nora Whats-Her-Name'),
  mail = str_to_lower(name) |> 
    str_replace_all(' ', '.') |> 
    paste0(
      c("@communicators.de",
        "@communicators.de",
        "@microsoft.com",
        "@apple.com")
    ) )


str_match(contact_info2$name, '([a-z]+) ([a-z-]+)')


```

We need to alert R that names involve a collection of upper and lower letters omitted in the two groups of strings.

```{r upper_lower_letters}
#| echo: true
#| warning: false

str_match(contact_info2$name, '([A-Za-z]+) ([A-Za-z-]+)')

```

#### Using str_replace()

We could have accomplished the same outcome using str_split. However, we want the regular expression to use str_replace. The sequence is:

1.  Identify target column or variable

2.  Pattern

3.  Replacement. Identify the group for the regular expression. In this case the first name is contained in \[,2\] and the last name in \[,3\], which can be identified by \\2 and \\3

However, we don't get the result we want.

```{r str_replace_group}
#| echo: true
#| warning: false

str_replace(
  contact_info2$name,
  '([A-Za-z]+) ([A-Za-z-]+)',
  '\2, \1' )

```

Correcting replacement. Remember that `\` is a reserved character in R. We could escape it using double `\\`. The order of listing the groups is signified by the number. \\\\2 stands for the second group which is the family name. \\\\1 stands for the first group which is the name.

```{r correct_replacement_str_replace}
#| echo: true
#| warning: false

str_replace(contact_info2$name,
  '([A-Za-z]+) ([A-Za-z-]+)',
  '\\2, \\1' )


```

#### Optional `?` symbol

Notice the numbers in the names are included. If we want to exclude those numbers we could expand the regular expression to capture the numbers associated to Otto Bauder 2 and Otto Bauder 21.

Remember that the regular expression creates three columns. The third column includes the number itself. By referring to columns 1 and 2, we only include first and last numbers. We also make the third group optional using `?` outside the group.

```{r exclude_numbers_str_replace}
#| echo: true
#| warning: false

str_replace(contact_info2$name,
  '([A-Za-z]+) ([A-Za-z-]+)( [0-9]+)?',
  '\\2, \\1' )

```

## Lesson 19

### How to match an exact number

While the `+` operator matches many things, sometimes you want an operator that matches an exact number of things. Such operator is particular useful when splitting data that has for example city abbreviations. For example matching a collection of exactly two. This operator is `{ }`

Trying to extract the city from the database. We could first rely on `str_view` to have a feeling of the way the strings are organized.

Looking for a pattern composed of capital letters.

1.  Step 1 : All capital letters

2.  Step 2 : All sets of capital letter

3.  Step 3: Search for exact matches using `{}` . Using `{}` produces cities as well as the first two letters of USA.

4.  Step 4: Alternatively, specifying ranges of matches we want to find. For instance, finding two or three matches `{2,3}`

#### Using str_view() to visualize the groups of strings

```{r match_exact_number}
#| echo: true
#| warning: false

city_tib <- tibble(
  city = c("New York, NY, USA",
           "San Diego, CA, USA",
           "Houston, USA",
           "Berlin, Germany",
           "Ulm, BW, Germany")
)

#Step 1 All capital letter
str_view(city_tib$city, "([A-Z])")

#Step 2 All sets of capital letters
str_view(city_tib$city, "([A-Z]+)")

#Step 3 Looking for exact matches for two upper letters
str_view(city_tib$city, "([A-Z]{2})")

#Step 4 Specifying range of matches for up to three letters
str_view(city_tib$city, "([A-Z]{2,3})")

```

### Using regexp `str_match` to split the column

We want to split the city vector using `str_match`. Notice that the vector starts with city names, with a combination of capital and lower letters.

-   To single out the first column, we need to specify the regexp associated to the first group which includes the name of the State; namely (`[A-Za-z ]+)` .

-   The second group constitutes the abbreviation of the city, which is composed by two capital letters; namely, (`, [A-Z]{2})` preceded by a comma and a space.

-   Adding a `?` makes the second group, city, optional (`, [A-Z]{2})?`

-   Including country requires a third group, preceded by a comma and a space, which can also be optional `(, [A-Za-z]+)?`.

-   We can exclude the comma associated with the first group (country) by using `:?` as follows `(?: ,)?.`

```{r split_column_inside}
#| echo: true
#| warning: false

str_match(city_tib$city, '[A-Za-z ]+')

#Another version, which we are grouping

city_tib$city |> 
  str_match('([A-Za-z ]+)')

#* Specifying we want to match the name of the city, followed by a
#* comma, and then  by the abbreviation of the state. The abbreviation
#* of the state is composed by exactly two letters. And optional

city_tib$city |> 
  str_match('([A-Za-z ]+)(, [A-Z]{2})')

#*Using optional includes Berlin listing the state as NA. 
#*Add an optional ? since the city may appear or not

city_tib$city |> 
  str_match('([A-Za-z ]+)(, [A-Z]{2})?')

#Including country by adding another group
city_tib$city |> 
  str_match('([A-Za-z ]+)(, [A-Z]{2})?, ([A-Za-z]+)?')

```

#### Checking errors in regular expressions str_match()

Notice this string includes commas in the state abbreviations column `[, 3]`.

```{r check_error_regexp_str_match}
#| echo: true
#| message: false

#Including country by adding another group
city_tib$city |> 
  str_match('([A-Za-z ]+)(, [A-Z]{2})?, ([A-Za-z]+)?')

```

Let's try to get rid of the comma in the second column for the city abbreviation.

Eliminating comma followed by space in the third column by taking away the comma in the second group by using the question mark followed by : or `(?: ,)`. We also need to remind R that this comma may appear or not.

```{r eliminating_comma_city}
#| echo: true
#| message: false

city_tib$city |> 
  str_match('([A-Za-z ]+)(?:, )?([A-Z]{2})?, ([A-Za-z]+)?')

```

### Creating a tibble after splitting out vector

And to get nice column names, we can use the tibble `.name_repair =` function. It produces nice column names.

```{r creating_tibble_after_splitting}
#| echo: true
#| warning: false

city_tib$city |> 
  str_match('([A-Za-z ]+)(?:, )?([A-Z]{2})?, ([A-Za-z]+)?') |> 
  as_tibble(
    .name_repair = function(x) c("full", 
                                 "city", 
                                 "state",
                                 "country") )

```

### Separate wider using separate_wider_regex() function

Remember with `separate_wider_regex()` we are already doing the grouping eliminating the need of using parenthesis. However, this code produces an error: invalid number of groups. It did not like leaving `(?:, )` by itself

```{r separate_wider_cities}
#| echo: true
#| warning: false

# '([A-Za-z ]+)(?:, )?([A-Z]{2})?, ([A-Za-z]+)?'

city_tib |> 
  separate_wider_regex(
    cols = city,
    patterns = c(
      city = '[A-Za-z ]+',
      '(?:, )',
      state = '([A-Z]{2}?)', #We need to use the parenthesis here
      ', ',
      country = "[A-Za-z]+" 
    ) )


```

#### Detecting errors in the separate_wider_reg() code

But this produces a different error, prompting the use of the debug mode.

```{r detect_error_sep_wider_reg}
#| echo: true
#| warning: false

city_tib |> 
  separate_wider_regex(
    cols = city,
    patterns = c(
      city = '[A-Za-z ]+',
      '(?:, )',
      state = '(?:[A-Z]{2}?)', #We need to use the parenthesis here
      ', ',
      country = "[A-Za-z]+" 
    ) )


```

##### Requesting the use of the debug mode

```{r debug_reg_exp_mode}
#| echo: true
#| warning: false

city_tib |> 
  separate_wider_regex(
    cols = city,
    patterns = c(
      city = '[A-Za-z ]+',
      '(?:, )',
      state = '(?:[A-Z]{2}?)', #We need to use the parenthesis here
      ', ',
      country = "[A-Za-z]+" 
    ),
    too_few = 'debug')

```

There is always an issue when the state is missing.

The problem can be traced to the omission of the question mark

```{r correct_reg_exp_mode}
#| echo: true
#| warning: false

city_tib |> 
  separate_wider_regex(
    cols = city,
    patterns = c(
      city = '[A-Za-z ]+',
      '(?:, )?', #Adding ommited question mark at the end
      state = '(?:[A-Z]{2}?)', #We need to use the parenthesis here
      ', ',
      country = "[A-Za-z]+" 
    ),
    too_few = 'debug')


```

Running the script again without the `debug` option

```{r correct_reg_exp_mode_no_debug}
#| echo: true
#| warning: false

city_tib |> 
  separate_wider_regex(
    cols = city,
    patterns = c(
      city = '[A-Za-z ]+',
      '(?:, )?',
      state = '(?:[A-Z]{2})?',
      ', ',
      country = '[A-Za-z]+'
    )
  )


```

## Lesson 20

### RexEx: The \* operator

Trying to write a regular expression that could describe the vector displayed below.

Notice that Hi can be followed by space, but not always. We can describe this situation using the special operator `?` alternative.

```{r the_*_operator}
#| echo: true
#| warning: false

str_view(
  c('Hi!', 'Hi again!', 'Hi  again!'),
  'Hi( again)?!'
)


```

Notice that this regular expression only catches two sentences. The sentence not captured has two white spaces between `Hi` and `again`. We can add `{ }` to signify the potential number of additional spaces between Hi and again.

```{r catching_spaces}
#| echo: true
#| warning: false

str_view(
  c('Hi!', 'Hi again!', 'Hi  again!'),
  'Hi( ){0,5}(again)?!'
)

```

Another option to allow the possibility that white spaces can go from zero to an infinite number.

```{r handling_white_spaces}
#| echo: true
#| warning: false

str_view(
  c('Hi!', 'Hi again!', 'Hi  again!'),
  'Hi( ){0,}(again)?!'
)


```

Another alternative, we could use the star operator `*`.

```{r alternative_spaces}
#| echo: true
#| warning: false

str_view(
  c('Hi!', 'Hi again!', 'Hi  again!'),
  'Hi( )*(again)?!'
)

```

## Lesson 21

### RexEx: Match things at the beginning & end of text

Example of how to search for things and the beginning and end. Extracting words that start with `r`.

### Using str_starts() function

```{r match_beg_end}
#| echo: true
#| warning: false

x <- c("regex", "regular", "expression")

#View start with r
str_starts(x, 'r')

#You could also extract the variables with r

x[str_starts(x, 'r')]

#Extracting strings that start with r and end with x

x[str_starts(x, 'r') & str_ends(x,'x')]


```

### String Subset Using `^` (start) and `$` (end)

An alternative approach to extract strings that start and end with specific characters, using special annotations

```{r alternative_extraction}
#| echo: true
#| warning: false

str_subset(x, '^r')

str_subset(x, 'x$')

#Combining all of these expressions
# Start with an x and end with an x

str_subset(x, '^rx$')

#* Correct approach is to signify a series of characters between 
#* desired start and end of characters

str_subset(x, '^r.+x$')


```

We could use this approach for include some patterns.

```{r search_comb_letters}
#| echo: true
#| warning: false

#Searching for regular

str_subset(x, '^regu')

#* It can also be used to search for potential groups of characters
#* for instance the group `regu` can be there or not

str_subset(x, '^(regu)?')

# Another example: start with an r or an n

x <- c("regex", "regular", "expression", 'night')

str_subset(x, '^(r|n)')

#Suppose we want to catch words that end with an r or  an n

str_subset(x, '(r|n)$')

#Get things that end with r or t

str_subset(x, '(r|t)$')

#* We can also combined groupings: start with either r or n and end
#* with either n or t

str_subset(x, '^(r|n).+(r|t)$')



```

## Lesson 22

### RegEx: The `not` operator

The `^` not operator can be used to instruct R to look for all but certain strings.

-   Searching for fruits containing letter r

-   Searching for fruits not containing letter r

-   Searching for fruits with

-   Using str_subset() to get a group of fruits \[\^r\]

```{r not_oper_1}
#| echo: true
#| warning: false


fruit[1:7]

#Searching for names of fruits containing the letter r
str_view(fruit[1:7], '[r]')

#Searching for names of fruits not containing the letter r
str_view(fruit[1:7], '[^r]')

#Searching for names of fruits not containing the letters ar together
str_view(fruit[1:7], '[^ar]')

#Using str_subset() to identify fruits not starting with r
str_subset(fruit[1:7], '[^r]')


```

Modifying regular expression to identify fruits containing no r at all. We can do so by using the add the asteric operator `*` . This operator means 0, 1 or many.

-   str_subset(fruit\[1:7\], "\[\^r\]\*") but still does not produce what we want

-   str_view reveals that r still is part of the strings being captured

-   combining beginning and end of the string. We start with not r and we we end with not r

    -   We start with `^[^r]` and the end string not r using `*` : `^[^r]*$`

        -   `^[^r]*$`

        -   This option produces the correct three fruits with no r

-   Alternatively we could use a `+` instead of an `^[^r]+$`

```{r not_oper_2}
#| echo: true
#| warning: false

#Using astering operator
str_subset(fruit[1:7], '[^r]*')

#Unsing str_view to check the output
str_view(fruit[1:7], '[^r]*')

#Using beginning and end of string to eliminate begining and end
str_view(fruit[1:7], '^[^r]*$')

#Using subset to identify fruits with no r
str_subset(fruit[1:7], '^[^r]*$')

#Alternatively we could use a `+` instead of an `*`
str_subset(fruit[1:7], '^[^r]+$')

str_view(fruit[1:7], '^[^r]+$')
```

## Lesson 23

### RegEx: Special collections

```{r}

```
